#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Feb  5 14:53:41 2020

@author: 7ka

"""
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit import DataStructs
import multiprocessing as mp
import os.path
import sys
import random


#MAIN
rawListOfArguments = sys.argv

##### Raw list of arguments entered into the function so as to make it callable from teminal######
def rawListOfArgs(arguments):
    
    global inputDB
    global inputCmpdsOfInt
    global inputFP 
    global inputSubsamplingRate
    global theTopPercent
    global inputComp
    global DBOutputFilepath
    global CmpdOfIntOutFilePath
    

    inputDB = arguments[1]
    inputCmpdsOfInt = arguments[2]
    inputFP = arguments[3]
    inputSubsamplingRate = float(arguments[4])
    theTopPercent = float(arguments[5])
    inputComp = arguments[6]
    DBOutputFilepath = inputDB + "_" + inputFP + "_" + inputComp + '_' + 'subSamplingRate-' + str(inputSubsamplingRate) + '_' + 'topX%-' + str(theTopPercent) + ".txt"
    CmpdOfIntOutFilePath = inputCmpdsOfInt + "_" + inputFP + "_" + inputComp + '_' + 'subSamplingRate-' + str(inputSubsamplingRate) + '_' + 'topX%-' + str(theTopPercent) + ".txt"

### Loads a csv and the fist column is the smiles and the second column is the name.  Mol file is generated from rdkits Chem.MolFromSmiles and the list of lists is returned containing the smiles, name, and mol
def smiles2DF(file):
    
    smilesList = []
    nameList = []
    
    with open(file, 'r') as f:
        
        for line in f:
            splitLine = line.split(',')
            smilesList.append(splitLine[0])
            nameList.append(splitLine[1])
            
    ROMol_list = []
    
    for i in range(0, len(smilesList)):
        mol = Chem.MolFromSmiles(smilesList[i])
        ROMol_list.append(mol)
  
    complete_list = []
    
    for i in range(0, len(smilesList)):
        complete_list0 = []
        complete_list0.append(smilesList[i])
        complete_list0.append(ROMol_list[i])
        complete_list0.append(nameList[i])
        complete_list.append(complete_list0)

    return complete_list
########################################################

### Reads the SDF file downloaded from pubchem and searches for the CID and Smiles. The smile is then used for Rdkits Chem.MolFromSmiles to create the mol. The returned item is a list of lists the same as the smiles2DF function
def sdf2DF(file):
    
    pubchemID_list = []
    smiles_list = []
    ROMol_list = []
    
    with open(file, 'r') as f:
        
        for line in f:
            searchTerm1 = '> <PUBCHEM_COMPOUND_CID>'
            searchTerm2 = '> <PUBCHEM_OPENEYE_CAN_SMILES>'
            
            if searchTerm1 in line:
                pubchemID_list.append(next(f))
                
            if searchTerm2 in line:
                smiles_list.append(next(f))
    
    pubchemID_list_s = []
    smiles_list_s = []
    
    for i in range(0, len(pubchemID_list)):
        strippedline = pubchemID_list[i].strip('\n')
        strippedline1 = smiles_list[i].strip('\n')
        pubchemID_list_s.append(strippedline)
        smiles_list_s.append(strippedline1)
        
    for i in range(0, len(smiles_list_s)):
        mol = Chem.MolFromSmiles(smiles_list_s[i])
        ROMol_list.append(mol)
    
    complete_list = []
    
    for i in range(0, len(smiles_list_s)):
        
        complete_list0 = []
        complete_list0.append(smiles_list_s[i])
        complete_list0.append(ROMol_list[i])
        complete_list0.append(pubchemID_list_s[i])
        complete_list.append(complete_list0)
        
    return complete_list
###########

### Sub sample either of the data and at random according to the input subsampling percentage, returns the subsampled data 
def subsampleDF(df3):

    global inputSubsamplingRate
   
    randomsubsampledData = random.sample(df3, int(round(len(df3) * inputSubsamplingRate)))

    return randomsubsampledData
######################

###### Generates a fingerpirnt based on the subsampled data and data in entirity. The input is the mol file generated by Rdkit and the output is the fingerprint.
def genProperFP(smiles, mol, name):
    
    global inputFP
   
    if mol is not None:
       
        if inputFP == 'topo':
            fp = Chem.RDKFingerprint(mol)

        if inputFP == 'fcfp6':
            fp = AllChem.GetMorganFingerprintAsBitVect(mol, 3, useFeatures = True, nBits = 2048)

        if inputFP == 'ecfp6':
            fp = AllChem.GetMorganFingerprintAsBitVect(mol, 3, useFeatures = False, nBits = 2048)
            
        if inputFP == 'maccs':
            fp = AllChem.GetMACCSKeysFingerprint(mol)
                
        if inputFP == 'fpn4':
            fp2 = AllChem.GetMACCSKeysFingerprint(mol)
            fp3 = AllChem.GetMorganFingerprintAsBitVect(mol, 3, useFeatures = False, nBits = 2048)
            fp4 = AllChem.GetMorganFingerprintAsBitVect(mol, 3, useFeatures = True, nBits = 2048)
            fp = fp2 + fp3 + fp4
    
    else:
        fp = 'None'
        
    return smiles, fp, name
#################################

##### Takes two explicit bit vector objects and compares them using one of the folowing comparison methods####
def singleComparison(a, b, cmpdID, DBID):
    
    global inputComp
    
    if a != 'None' and b != 'None':
        
        if inputComp == 'Tan':
            tempy = DataStructs.TanimotoSimilarity(a, b)
            
        if inputComp == 'Dice':
            tempy = DataStructs.DiceSimilarity(a, b)
            
        if inputComp == 'Sokal':
            tempy = DataStructs.SokalSimilarity(a, b)
            
        if inputComp == 'Russ':
            tempy = DataStructs.RusselSimilarity(a, b)
            
        if inputComp == 'Rogot':
            tempy = DataStructs.RogotGoldbergSimilarity(a, b)
            
        if inputComp == 'Mccon':
            tempy = DataStructs.McConnaugheySimilarity(a, b)
            
        if inputComp == 'Kulcz':
            tempy = DataStructs.KulczynskiSimilarity(a, b)
            
        if inputComp == 'Cosine':
            tempy = DataStructs.CosineSimilarity(a, b)
            
    else:
        tempy = 'None'
        
    return tempy, cmpdID, DBID
########################################################################     
       

### This function outputs a key for the database of interest
    
def DBkeyCreation(df):
   
    global inputFP

    f = open(DBOutputFilepath[:-4] + '.key.txt', 'w')
    
    for i in df:
        f.write(str(i[0]) + '\t' + str(i[2]) + '\n')

    f.close()

    return df
##########
    
### Creates a key for the compounds of interest    
def cmpdOfIntKeyCreations(df):
    
    global inputFP

    f = open(CmpdOfIntOutFilePath[:-4] + '.key.txt', 'w')
   
    for i in df:
        f.write(str(i[0]) + '\t' + str(i[2]) + '\n')

    f.close()

    return df
#############


####This function compares the compounds of interest to the database
def cmpdsOfIntComparedToDatabase(cmpdsOFInterst, database, comparisonType, fingerprintType, thresh = 0):
    
    listWithCmpdsToCompare = []

    for i in cmpdsOFInterst:
        
        for j in database:
            listWithCmpdsToCompare.append(i[1])
            listWithCmpdsToCompare.append(j[1])
            listWithCmpdsToCompare.append(i[2])
            listWithCmpdsToCompare.append(j[2])
    
    nestedCmpdlist = [listWithCmpdsToCompare[q:q + 4] for q in range(0, len(listWithCmpdsToCompare), 4)]
    
    results = []
    
    pool = mp.Pool(mp.cpu_count())
    tempvalue = pool.starmap(singleComparison, nestedCmpdlist)

    pool.close()

    for i in tempvalue:
        
        if i[0] == 'None':
            continue
        
        elif thresh == 0:
            results.append(i[0])
            results.append(i[1])
            results.append(i[2])
            
        else:
            if i[0] >= thresh:
                results.append(i[0])
                results.append(i[1])
                results.append(i[2])
           
    return results
########

#### This function is called after subsampling, fingerprint generation, and comparison.  We need to sort, count total number in subsample, determine topX%, select threshold, and return the threshold.
def determineThresholdfromSubsample(list1):
    
    global theTopPercent

    simlist = []    
    
    for i in range(0, len(list1), 3):
        
        if list1[i] == 'None':
            continue
        
        else:
            simlist.append(list1[i])
    

    sortedsimlist = sorted(simlist)

    totalSims = len(sortedsimlist)

    topCandidates = round(totalSims * theTopPercent)

    toSetThresh = (sortedsimlist[-topCandidates:])

    threshold = toSetThresh[0]

    return threshold
#######


#### Writes out the candidates to the proper file
def writeOutTopCandidates(list1):

    f = open(DBOutputFilepath, 'w')
    
    for i in range(0, len(list1), 3):
        f.write(str(list1[i + 2]) + '\t' + str(list1[i + 0]) + '\n')
    
    f.close()
##########
    

#####Checks the raw list of arguments and ensures that they are valid before proceeding with the program #######
def areRawParametersValid(rawListOfArguments):
    
    validityDB = True
    validityCompounds = True
    validityFP = True
    validitySubsampligRate = True
    validityTopXPercent = True
    validityComp = True
    validityCmpdOutput = False
    validityDBOutput = False
    
    if os.path.isfile(inputDB):
        print ("input DB exists")
    else:
        validityDB = False
        
    if os.path.isfile(inputCmpdsOfInt):
        print('input compounds of interest exist')
    else:
        validityCompounds = False
        
    if inputFP == 'topo' or inputFP == 'maccs' or inputFP == 'ecfp6' or inputFP == 'fcfp6' or inputFP == 'fpn4':
        print ('Valid FP')
    else:
        validityFP = False
        
    if inputSubsamplingRate >= 0 and inputSubsamplingRate <= 1 :
        print ('Valid sub sampeling rate')
    else:
        validitySubsampligRate = False
        
    if theTopPercent >= 0 and theTopPercent <=1:
        print('valid top percent')
    else:
        validityTopXPercent = False
        
    if inputComp == 'Dice' or inputComp == 'Tan' or inputComp == 'Sokal' or inputComp == 'Russ' or inputComp == 'Rogot' or inputComp == 'Mccon' or inputComp == 'Kulcz' or inputComp == 'Cosine':
        print ('Valid Comparison type')
    else:
        validityComp = False
    
    if os.path.isfile(CmpdOfIntOutFilePath):
        print('compound output file exists')
        validityCmpdOutput = False
    else:
        print('Compound output file doesnt not exist, we can proceed')
        validityCmpdOutput = True
        
    if os.path.isfile(DBOutputFilepath):
        print ('output file exists')
        validityDBOutput = False
    else:
        print ('Database output File Does Not Exists! Which is Good!')
        validityDBOutput = True
        
    if(validityDB == False):
        print('aborting! invalid database location')
        sys.exit()
        
    if(validityCompounds == False):
        print('aborting! invalid componds')
        sys.exit()
        
    if(validityFP == False):
        print('aborting! invalid FP option')
        sys.exit()
        
    if(validitySubsampligRate == False):
        print("aborting! invalid subsampling rate!")
        sys.exit()
    
    if(validityTopXPercent == False):
        print('aborting! invalid topX percentage selection')
        sys.exit
        
    if(validityComp == False):
        print('aborting! Invalid comparison type')
        sys.exit()
        
    if(validityCmpdOutput  == False):
        print('aborting! Outputfile Exists')
        sys.exit()
    
    if(validityDBOutput  == False):
        print('aborting! Outputfile Exists')
        sys.exit()
        
    if(validityDB == True and validityCompounds == True and validityFP == True and validitySubsampligRate == True and validityTopXPercent == True and validityComp == True and validityCmpdOutput == True and validityDBOutput == True):
        return True
    else:
        return False

rawListOfArgs(rawListOfArguments)

passed = areRawParametersValid(rawListOfArguments)

if passed == True:
    print('Prepare to Launch')
else:
    print("PROBLEMS!")


#####Main program to call all the functions.  Need to apply some if then statements in the final program so people can choose to output a graph, sdf or smiles input, potetinally clustering options? ######
def main():
    
    print('Starting the program')
    print('Loading Reference Database')
    cmpdDatabase = sdf2DF(inputDB)
    print('Loading Compounds of Interest')
    cmpdsOFInterest = smiles2DF(inputCmpdsOfInt)
    print('All small molecules have been loaded')
    print('Starting to subsample the molecules from the Reference Database')
    subDatabase = subsampleDF(cmpdDatabase)
    print('The reference database has been subsampled')
    print('Generating the fingerprints for the subsample database')
    pool = mp.Pool(mp.cpu_count())
    databaseFingerprints = pool.starmap(genProperFP, subDatabase)
    pool.close()
    print('Writing out a key for the Database')
    DBDFforSim = DBkeyCreation(databaseFingerprints)
    print('Generating the fingerprints for the compounds of interest')
    pool1 = mp.Pool(mp.cpu_count())
    cmpdsOfIntFps = pool1.starmap(genProperFP, cmpdsOFInterest)
    pool1.close()
    print('Writing out a key for the compounds of interest')
    cmpdsForSim = cmpdOfIntKeyCreations(cmpdsOfIntFps)
    print('Fingerprints for the subsample generated')
    print('Starting similarity comparison for the subsampled data')
    susampledComparisonData = cmpdsOfIntComparedToDatabase(cmpdsForSim, DBDFforSim, inputComp, inputFP)
    print('Similarities have been calculated for the subsampled data')
    print('Determining a threshold based of the topx% set by user based off the similaritiy scores for the subsampled data')
    threshold = determineThresholdfromSubsample(susampledComparisonData)
    print('The threshold has been determined to be' + ' ' + str(threshold))
    print('Generating fingerprints for all of the data')
    pool2 = mp.Pool(mp.cpu_count())
    compoundsFromDatabaseAboveThreshold = pool2.starmap(genProperFP, cmpdDatabase)
    pool2.close()
    DBforSimsAboveThresh = DBkeyCreation(compoundsFromDatabaseAboveThreshold)
    print('All fingperints have been generated and the comparisons are being made.  Similaries between compounds above the threshold will be returned')
    simsAboveThresh = cmpdsOfIntComparedToDatabase(cmpdsForSim, DBforSimsAboveThresh, inputComp, inputFP, threshold)
    print('Similarities above the threshold have been returned and will be written to file')
    writeOutTopCandidates(simsAboveThresh)
    print('The similarity pipeline is complete')

    
########################################################### 

main()
